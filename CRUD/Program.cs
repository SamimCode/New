using Entities;
using Microsoft.EntityFrameworkCore;
using Repositories;
using RepositoryContracts;
using ServiceContracts;
using Services;
using CRUD.Middleware;
using IdentityEntities;
using Microsoft.AspNetCore.Identity.EntityFrameworkCore;
using Microsoft.AspNetCore.Identity;
using Microsoft.AspNetCore.Authorization;

var builder = WebApplication.CreateBuilder(args);

//Enables only Console logging (Terminal) and removes Debug logging in Visual Studio
builder.Host.ConfigureLogging(loggingProviders =>
{
    loggingProviders.ClearProviders();
    loggingProviders.AddConsole();
    loggingProviders.AddDebug();
    loggingProviders.AddEventLog();
});

builder.Services.AddControllersWithViews();

//Add services to IoC container

//Add Repositories to IoC container
builder.Services.AddScoped<ICountriesRepository, CountriesRepository>();
builder.Services.AddScoped<IPersonsRepository, PersonsRepository>();

//Since we are using In-Memory Collection so to persist it we are creating a Singleton service
//builder.Services.AddSingleton<ICountriesService, CountriesService>();
//builder.Services.AddSingleton<IPersonsService, PersonsService>();

//Now we are using a SqlServer DB so use Scoped service
builder.Services.AddScoped<ICountriesService, CountriesService>();
builder.Services.AddScoped<IPersonsService, PersonsService>();

//Add DbContext as a service

//These options params will be supplied to the DbContext constructor class via child constructor
//This is by default will be a Scoped Service
builder.Services.AddDbContext<ApplicationDbContext>(options =>
    options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection")));

//Enable Identity in this project
builder.Services.AddIdentity<ApplicationUser, ApplicationRole>(options =>
{
    //Configure Password Complexity
    options.Password.RequiredLength = 5;
    options.Password.RequireNonAlphanumeric = false;
    options.Password.RequireUppercase = false;
    options.Password.RequireLowercase = true;
    options.Password.RequireDigit = false;
    options.Password.RequiredUniqueChars = 3;
})
.AddEntityFrameworkStores<ApplicationDbContext>()
.AddDefaultTokenProviders()
.AddUserStore<UserStore<ApplicationUser, ApplicationRole, ApplicationDbContext, Guid>>()
.AddRoleStore<RoleStore<ApplicationRole, ApplicationDbContext, Guid>>();

builder.Services.AddAuthorization(options =>
{
    //enforces authorization policy (user must be authenticated) for all controllers and actions
    options.FallbackPolicy = new AuthorizationPolicyBuilder().RequireAuthenticatedUser().Build();
});

builder.Services.ConfigureApplicationCookie(options =>
{
    //Cookie settings
    options.LoginPath = "/Account/Login";
});

var app = builder.Build();

//enable httplogging
//http logs are generated by asp.net core so we need to enable them in appsettings.development.json
app.UseHttpLogging();

if (app.Environment.IsDevelopment())
{
    app.UseDeveloperExceptionPage();
}
else
{
    app.UseExceptionHandler("/Error");
    app.UseExceptionHandlingMiddleware();
}

app.UseStaticFiles();

//Identify action method based on route
app.UseRouting();

//enable authentication, this enables to reqcognize the user after signin
//reads the identity info from cookie stored in browser
//Ensures whether user is logged in or not
app.UseAuthentication();

//evaluates if the current user has access to a particular resource or not
//validates access permission of user
//Ensures whether user has permission to access a resource (action method) or not
app.UseAuthorization();

//Execute filter pipeline (action + filters)
app.MapControllers();

app.Run();
